/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2206                                  |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
version 2.0;
format ascii ;
class volVectorField ;
location "0";
object blockageGradient;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
dimensions [0 -1 0 0 0 0 0];
internalField #codeStream
{
codeInclude
#{
# include </usr/include/CGAL/Exact_predicates_inexact_constructions_kernel.h>
# include </usr/include/CGAL/Delaunay_triangulation_2.h>
# include </usr/include/CGAL/Interpolation_traits_2.h>
# include </usr/include/CGAL/natural_neighbor_coordinates_2.h>
# include </usr/include/CGAL/interpolation_functions.h>
# include "fvCFD.H"
# include <IFstream.H>
# include <OFstream.H>
# include <ctime>
# include "clock.H"
# include "string.H"
# include <sstream>
# include <iomanip>
# include <cmath>
# include "fvc.H"
# include "fvcSnGrad.H"
#};
codeOptions
#{
-I$(LIB_SRC)/finiteVolume/lnInclude \
-I$(LIB_SRC)/meshTools/lnInclude
#};
codeLibs
#{
-lmeshTools \
-lfiniteVolume
#};
code
#{
const IOdictionary & d = static_cast < const IOdictionary &>(dict);
const fvMesh& mesh = refCast < const fvMesh >(d.db());
const volScalarField& blockage = mesh.lookupObject<volScalarField>("blockage");
volVectorField gradBlockage = fvc::grad(blockage);
typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef K::FT Coord_type;
typedef K::Point_2 Point;
typedef std::map<Point , Coord_type , K::Less_xy_2> Coord_map;
typedef std::vector<std::pair<Point , Coord_type>> C;
scalar y, z, RADIUS;
vectorField blockageGradient(mesh.nCells() , vector(0,0,0));
Coord_map value_bl; 
List <vector > blockage_data;
IFstream bl("blockage_data");
bl >> blockage_data;
forAll(blockage, i)
{
y = mesh.C()[i][1];
z = mesh.C()[i][2];
RADIUS = sqrt(y*y + z*z);
blockageGradient[i][0] = gradBlockage[i][0];
blockageGradient[i][1] = gradBlockage[i][1];
blockageGradient[i][2] = RADIUS*gradBlockage[i][2];
}

blockageGradient.writeEntry("", os);
#};
};
boundaryField
{
"(hub|shroud)"
{
type slip ;
}
inlet
{
type fixedValue ;
value uniform (0 0 0);
}
outlet
{
type zeroGradient ;
}
    frontAndBack_left
    {
        type            wedge;
    }
    frontAndBack_right
    {
        type            wedge;
    }
}

// ************************************************************************* //
