/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2206                                  |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
version 2.0;
format ascii ;
class volScalarField ;
location "0";
object blockage;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
dimensions [0 0 0 0 0 0 0];
internalField #codeStream
{
codeInclude
#{
# include </usr/include/CGAL/Exact_predicates_inexact_constructions_kernel.h>
# include </usr/include/CGAL/Delaunay_triangulation_2.h>
# include </usr/include/CGAL/Interpolation_traits_2.h>
# include </usr/include/CGAL/natural_neighbor_coordinates_2.h>
# include </usr/include/CGAL/interpolation_functions.h>
# include "fvCFD.H"
# include <IFstream.H>
# include <OFstream.H>
# include <ctime>
# include "clock.H"
# include "string.H"
# include <sstream>
# include <iomanip>
# include <cmath>
#};
codeOptions
#{
-I$(LIB_SRC)/finiteVolume/lnInclude \
-I$(LIB_SRC)/meshTools/lnInclude
#};
codeLibs
#{
-lmeshTools \
-lfiniteVolume
#};
code
#{
const scalar NBLADES = 30;
const scalar TMAX = 0.005;
const scalar CHORD = 0.05;
const IOdictionary & d = static_cast < const IOdictionary &>(dict);
const fvMesh& mesh = refCast < const fvMesh >(d.db());
scalarField blockage(mesh.nCells(), 0);
scalar x,y,z,RADIUS,BL;
typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef CGAL::Delaunay_triangulation_2<K> Delaunay_triangulation;
typedef K::FT Coord_type;
typedef K::Point_2 Point;
typedef std::map<Point , Coord_type , K::Less_xy_2> Coord_map;
typedef CGAL::Data_access<Coord_map> Value_access;
typedef std::vector<std::pair<Point , Coord_type>> C;
scalar PI, THICKNESS;
Delaunay_triangulation Tbl; 
Coord_map value_bl; 
List <vector > blockage_data;
IFstream bl("blockage_data");
bl >> blockage_data;
forAll(blockage, i)
{
x = mesh.C()[i][0];
y = mesh.C()[i][1];
z = mesh.C()[i][2];
RADIUS = sqrt(y*y + z*z);
PI = M_PI;
THICKNESS = 4*TMAX/CHORD*x-4*TMAX/(CHORD*CHORD)*x*x;
BL = ((2*PI*RADIUS/NBLADES)-THICKNESS)/(2*PI*RADIUS/NBLADES);
if (BL > 0 && BL <= 1){
	blockage[i] = BL;
}
else{			
// ensure that rest of field is NOT 0, but 1 (does not work by initialization of field)
	blockage[i] = 1;
}
}
blockage.writeEntry("", os);
#};
};
boundaryField
{
"(hub|shroud)"
{
type slip ;
}
inlet
{
type fixedValue ;
value uniform 1;
}
outlet
{
type zeroGradient ;
}
    frontAndBack_left
    {
        type            wedge;
    }
    frontAndBack_right
    {
        type            wedge;
    }
}

// ************************************************************************* //
