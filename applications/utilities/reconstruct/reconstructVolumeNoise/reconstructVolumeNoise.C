
#include "List.H"
#include "OSspecific.H"
#include "Ostream.H"
#include "Switch.H"
#include "csv.H"
#include "dictionary.H"
#include "fileName.H"
#include "fileNameList.H"
#include "fileOperation.H"
#include "messageStream.H"
#include "scalarField.H"
#include "vectorField.H"
#include "volumeNoise.H"
#include <cstdlib>

#include "Time.H"
#include "argList.H"
#include "stdFoam.H"
#include "timeSelector.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[]) {
  using namespace Foam;

  argList::addNote(
      "Reconstruct csv files generated by volumeNoise postprocess tool");

  timeSelector::addOptions(false, Foam::Switch::FALSE);

#include "setRootCase.H"

#include "createTime.H"

  label nProcs{fileHandler().nProcs(args.path())};

  if (!nProcs) {
    FatalErrorInFunction << "No processor* directories found"
                         << exit(FatalError);
  }

  word const dictName("noiseDict");

#include "setSystemRunTimeDictionaryIO.H"

  Info << "Reading " << dictIO.name() << nl << endl;

  IOdictionary dict(dictIO);

  word const modelType(dict.get<word>("noiseModel"));

  if (modelType != Foam::noiseModels::volumeNoise::typeName) {
    FatalErrorInFunction << "Invalid noise model type: " << modelType
                         << exit(FatalError);
  }

  dictionary coeffs = dict.subDict(modelType + "Coeffs");

  wordList filteredFunctionObjectNames;
  coeffs.readEntry("filteredFieldFunctionObjectNames",
                   filteredFunctionObjectNames);

  dictionary readOptions = coeffs.optionalSubDict("writeOptions");

  bool readPrmsf = readOptions.getOrDefault("writePrmsf", true);
  bool readPSDf = readOptions.getOrDefault("writePSDf", true);
  bool readPSD = readOptions.getOrDefault("writePSD", true);
  bool readSPL = readOptions.getOrDefault("writeSPL", true);
  bool readOctaves = readOptions.getOrDefault("writeOctaves", true);

  // Create the processor databases
  PtrList<Time> read_database(nProcs);

  forAll(read_database, proci) {
    read_database.set(
        proci, new Time(Time::controlDictName, args.rootPath(),
                        args.caseName() / ("processor" + Foam::name(proci))));
  }

  Time write_database(Time::controlDictName, args.rootPath(), args.caseName());

  instantList timeDirs = timeSelector::select(read_database[0].times(), args);

  if (timeDirs.empty()) {
    WarningInFunction << "No times selected";
    exit(1);
  }

  forAll(filteredFunctionObjectNames, ffoni) {
    Info << "Processing " << filteredFunctionObjectNames[ffoni] << endl << endl;

    forAll(timeDirs, timei) {
      runTime.setTime(timeDirs[timei], timei);
      read_database[0].setTime(runTime);

      fileName fftInputDir = noiseModels::volumeNoise::getFftOutputDir(
          read_database[0], filteredFunctionObjectNames[ffoni]);

      fileNameList fftInputs = readDir(read_database[0].path() / fftInputDir);

      if (!fftInputs.empty()) {
        Info << "Found " << fftInputs.size()
             << " FFT frequencies at time=" << runTime.timeName() << endl;

        forAll(fftInputs, ffti) {
          word freq = noiseModels::volumeNoise::getFreqFromFftOutputFilename(
              fftInputs[ffti]);

          Info << "Collecting " << freq << " Hz" << endl;

          labelList globalIndices;
          vectorField centroids;
          scalarField volumes;
          scalarField prmsf;
          scalarField psdf;
          scalarField psd;
          scalarField spl;

          forAll(read_database, proci) {
            read_database[proci].setTime(runTime);

            IOobject read_from(
                noiseModels::volumeNoise::getFftOutputFilename(freq),
                noiseModels::volumeNoise::getFftOutputDir(
                    read_database[proci].time(),
                    filteredFunctionObjectNames[ffoni]),
                read_database[proci], IOobject::NO_READ, IOobject::NO_WRITE);

            labelList _local_indices;
            labelList _global_indices;
            vectorField _centroids;
            scalarField _volumes;
            scalarField _prmsf;
            scalarField _psdf;
            scalarField _psd;
            scalarField _spl;

            readCsv(read_from, std::make_pair("index", &_local_indices),
                    std::make_pair("global_index", &_global_indices),
                    std::make_pair("centroid", &_centroids),
                    std::make_pair("volume", &_volumes),
                    std::make_pair("Prmsf", readPrmsf ? &_prmsf : nullptr),
                    std::make_pair("PSDf", readPSDf ? &_psdf : nullptr),
                    std::make_pair("PSD", readPSD ? &_psd : nullptr),
                    std::make_pair("SPL", readSPL ? &_spl : nullptr));

            globalIndices.append(_global_indices);
            centroids.append(_centroids);
            volumes.append(_volumes);
            prmsf.append(_prmsf);
            psdf.append(_psdf);
            psd.append(_psd);
            spl.append(_spl);
          }

          write_database.setTime(runTime);

          IOobject write_to(
              noiseModels::volumeNoise::getFftOutputFilename(freq),
              noiseModels::volumeNoise::getFftOutputDir(
                  runTime, filteredFunctionObjectNames[ffoni]),
              write_database, IOobject::NO_READ, IOobject::NO_WRITE);

          writeCsv(write_to, globalIndices.size(),
                   std::make_pair("index", &globalIndices),
                   std::make_pair("centroid", &centroids),
                   std::make_pair("volume", &volumes),
                   std::make_pair("Prmsf", readPrmsf ? &prmsf : nullptr),
                   std::make_pair("PSDf", readPSDf ? &psdf : nullptr),
                   std::make_pair("PSD", readPSD ? &psd : nullptr),
                   std::make_pair("SPL", readSPL ? &spl : nullptr));
        }
      }

      /// 1/3 Octave
      fileName _13octaveInputDir =
          noiseModels::volumeNoise::get13OctaveOutputDir(
              read_database[0], filteredFunctionObjectNames[ffoni]);

      fileNameList _13octaveInputs =
          readDir(read_database[0].path() / _13octaveInputDir);

      if (!_13octaveInputs.empty()) {
        Info << "Found " << _13octaveInputs.size()
             << " 1/3 octave frequencies at time=" << runTime.timeName()
             << endl;

        forAll(_13octaveInputs, ffti) {
          word freq = noiseModels::volumeNoise::getFreqFromFftOutputFilename(
              _13octaveInputs[ffti]);

          Info << "Collecting " << freq << " Hz" << endl;

          labelList globalIndices;
          vectorField centroids;
          scalarField volumes;
          scalarField spl13;

          forAll(read_database, proci) {
            read_database[proci].setTime(runTime);

            IOobject read_from(
                noiseModels::volumeNoise::getFftOutputFilename(freq),
                noiseModels::volumeNoise::getFftOutputDir(
                    read_database[proci].time(),
                    filteredFunctionObjectNames[ffoni]),
                read_database[proci], IOobject::NO_READ, IOobject::NO_WRITE);

            labelList _local_indices;
            labelList _global_indices;
            vectorField _centroids;
            scalarField _volumes;
            scalarField _spl13;

            readCsv(read_from, std::make_pair("index", &_local_indices),
                    std::make_pair("global_index", &_global_indices),
                    std::make_pair("centroid", &_centroids),
                    std::make_pair("volume", &_volumes),
                    std::make_pair("SPL13", readPrmsf ? &_spl13 : nullptr));

            globalIndices.append(_global_indices);
            centroids.append(_centroids);
            volumes.append(_volumes);
            spl13.append(_spl13);
          }

          write_database.setTime(runTime);

          IOobject write_to(
              noiseModels::volumeNoise::getFftOutputFilename(freq),
              noiseModels::volumeNoise::getFftOutputDir(
                  runTime, filteredFunctionObjectNames[ffoni]),
              write_database, IOobject::NO_READ, IOobject::NO_WRITE);

          writeCsv(write_to, globalIndices.size(),
                   std::make_pair("index", &globalIndices),
                   std::make_pair("centroid", &centroids),
                   std::make_pair("volume", &volumes),
                   std::make_pair("SPL13", readOctaves ? &spl13 : nullptr));
        }
      }
    }
  }

  Info << "Done." << endl;
}
