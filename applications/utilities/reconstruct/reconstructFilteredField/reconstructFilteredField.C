
#include "List.H"
#include "OSspecific.H"
#include "Ostream.H"
#include "Switch.H"
#include "csv.H"
#include "dictionary.H"
#include "fileName.H"
#include "fileOperation.H"
#include "messageStream.H"
#include "scalarField.H"
#include "vectorField.H"
#include <cstdlib>

#include "Time.H"
#include "argList.H"
#include "stdFoam.H"
#include "timeSelector.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[]) {
  using namespace Foam;

  argList::addNote(
      "Reconstruct csv files generated by filteredVolumeField function "
      "object");

  timeSelector::addOptions(false, Foam::Switch::FALSE);

  argList::addArgument("name",
                       "name of the filteredVolumeField function object");

#include "setRootCase.H"

#include "createTime.H"

  word name = args.get<Foam::word>(1);

  dictionary const *functionObjectsDict =
      runTime.controlDict().findDict("functions");

  if (!functionObjectsDict) {
    FatalErrorInFunction << "No 'functions' dictionary found in controlDict"
                         << exit(FatalError);
  }

  dictionary const *filteredVolumeFieldDict =
      functionObjectsDict->findDict(name);

  if (!filteredVolumeFieldDict) {
    FatalErrorInFunction << "No '" << name
                         << "' dictionary found in functionObjects"
                         << exit(FatalError);
  }

  word field_name{filteredVolumeFieldDict->getOrDefault<word>("field", "p")};

  label nProcs{fileHandler().nProcs(args.path())};

  if (!nProcs) {
    FatalErrorInFunction << "No processor* directories found"
                         << exit(FatalError);
  }

  // Create the processor databases
  PtrList<Time> read_database(nProcs);

  forAll(read_database, proci) {
    read_database.set(
        proci, new Time(Time::controlDictName, args.rootPath(),
                        args.caseName() / ("processor" + Foam::name(proci))));
  }

  Time write_database(Time::controlDictName, args.rootPath(), args.caseName());

  instantList timeDirs = timeSelector::select(read_database[0].times(), args);

  if (timeDirs.empty()) {
    WarningInFunction << "No times selected";
    exit(1);
  }

  forAll(timeDirs, timei) {
    runTime.setTime(timeDirs[timei], timei);

    Info << "Collecting data for time step " << runTime.timeName() << endl;

    labelList indices;
    vectorField centroids;
    scalarField volumes;
    scalarField field;

    forAll(read_database, proci) {
      read_database[proci].setTime(runTime);

      IOobject read_from(name + ".csv", read_database[proci].time().timeName(),
                         read_database[proci], IOobject::NO_READ,
                         IOobject::NO_WRITE);

      labelList _local_indices;
      labelList _global_indices;
      vectorField _centroids;
      scalarField _volumes;
      scalarField _field;

      if (!isFile(read_from.objectPath())) {
        // WarningInFunction << "Cannot find file: " << read_from.objectPath()
        // << endl;
        continue;
      }

      readCsv(read_from, std::make_pair("index", &_local_indices),
              std::make_pair("global_index", &_global_indices),
              std::make_pair("centroid", &_centroids),
              std::make_pair("volume", &_volumes),
              std::make_pair(field_name.c_str(), &_field));

      indices.append(_global_indices);
      centroids.append(_centroids);
      volumes.append(_volumes);
      field.append(_field);
    }

    if (indices.empty()) {
      continue;
    }

    write_database.setTime(runTime);

    IOobject write_to(name + ".csv", write_database.time().timeName(),
                      write_database, IOobject::NO_READ, IOobject::NO_WRITE);

    writeCsv(write_to, indices.size(), std::make_pair("index", &indices),
             std::make_pair("centroid", &centroids),
             std::make_pair("volume", &volumes),
             std::make_pair(field_name.c_str(), &field));
  }
}
